#!/usr/bin/env python

# To directly call hwgen from shell, set a symbolic link by running
# ln -sf $PWD/hwgen.py /home/erik/.local/bin/hwgen

import os
import sys 
import argparse
#import getpass
#from datetime import date
from pathlib import Path
import yaml
from sympy.parsing.sympy_parser import parse_expr
import copy

#def gen_header(description,fp,comment="#"):
#    ''' generates header for auto-generated document '''
#    fp.write("{} EFA Autogenerated document (efa@eecs.berkeley.edu)\n".format(comment))
#    fp.write("{} User: {}\n".format(comment,getpass.getuser()))
#    fp.write("{} Date: {}\n".format(comment,date.today()))
#    fp.write("{} Description: {}\n".format(comment,description))
#
#def tex_command(cmd: str,arg: str = None, star: bool = False) -> str:
#    if arg is not None:
#        if star:
#            return '\\' + cmd + "*{" + arg + "}"
#        else:
#            return '\\' + cmd + "{" + arg + "}"
#    else:
#        return '\\' + cmd

#----------------------------------------------------------
# Generic code gen functions 
#----------------------------------------------------------
def write_comment(fp,msg,comment='//'):
    fp.write(f'{comment} {msg}\n')

def write_begin_section(fp,msg,comment='//'):
    ''' Writes fancy comment '''
    fp.write(f'{comment}{80*"-"}\n')
    write_comment(fp,msg,comment)
    fp.write(f'{comment}{80*"-"}\n')

def write_end_section(fp,comment='//'):
    ''' Writes fancy comment '''
    fp.write(f'{comment}{80*"-"}\n\n')

def write_yaml(fp,yml_obj,msg):
    write_begin_section(fp,msg)
    for line in yaml.dump(yml_obj).splitlines():
        write_comment(fp,line)
    write_end_section(fp)
    
#----------------------------------------------------------
# Verilog code gen functions 
#----------------------------------------------------------
def write_default_nettype(fp,nettype):
    fp.write(f"`default_nettype {nettype}\n")

def write_define(fp,name,value,tab=4*" "):
    fp.write(f'{tab}`define {name} {value}\n')

def write_localparam(fp,name,value,tab=4*" "):
    write_declaration(fp,'localparam',name,value,tab)

def write_declaration(fp,prefix,name,value,tab=4*" "):
    fp.write(f'{tab}{prefix} {name} = {value}\n')

def write_vlog_mod_begin(fp,name,*ports):
    ''' Writes beginning of verilog module
    ports: list of {name:,io:,datatype:,vec:} 
    '''
    fp.write(f'module {name}(\n')
    for i,port in enumerate(ports):
        write_vlog_port(fp,
            port['name'],port['io'],port['datatype'],port['vec'],last=(len(ports)-1)==i)

def write_vlog_port(fp,name,io,datatype,vec=None,last=False,tab=4*' '):
    if vec:
        fp.write(f'{tab}{io} {datatype} {vec} {name}')
    else:
        fp.write(f'{tab}{io} {datatype} {name}')
    if last:
        fp.write('\n);\n\n')
    else:
       fp.write(',\n')

# TODO 
# 1. Generate src file
#   a. Output config at top of file
#   b. port instantiation 
#   c. localparams (Totalwidth,segmentwidths,)
#   d. define single scan bits that is an inout port
#   e. create wires to connect all segments 
#   f. instantiate all segments 
# 2. Generate defines file
#   a. Output config at top of file
#   b. total Length
#   c. vector lengths flattened
#   d. vector lengths by mult

class ScanGenerator:
    ''' Simple class for generating tex hw files '''
    def __init__(self):
        # Pysilicon check
        self.home_dir = os.getenv('PYSILICON_HOME')
        if self.home_dir is None:
            print('PYSILICON_HOME variable not set')
            sys.exit(-1)
        # Argparse check
        self.options = self.parse_args()
        if Path(self.options.config).is_file() is False:
            sys.exit(-1)
        self.gen_chain()
    
    def parse_args(self):
        ''' Parse arguments '''
        parser = argparse.ArgumentParser(description="Generates verilog scan chains.")
        parser.add_argument(
            '-c', '--config',
            required=True,
            help='Scan chain configuration file.'
        )
        return parser.parse_args()

    def evaluate_cells(self,config):
        ''' Uses parameters to evaluate cells '''
        self.full_width = 0
        params = config['parameters']
        for cell in config['cells']:
            for item,val in cell.items():
                if isinstance(val,str) and item in ['width','mult']:
                    cell[item] = parse_expr(val,params)
            self.full_width += cell['width']*cell['mult']
        return config
    
    def gen_chain(self):
        ''' Generates all files for scan chain '''
        # Read Config
        with open(self.options.config,'r') as fp:
            self.config = yaml.load(fp,Loader=yaml.SafeLoader)
        self.og_config = copy.deepcopy(self.config)
        self.config = self.evaluate_cells(self.config)
        with open(self.config['name']+'.v','w') as sfp:
            with open(self.config['name']+'_defines.v','w') as dfp:
                self.gen_src(sfp,dfp)

    def write_src(self,fp):
        ''' Writes src file '''
        # YAML config 
        write_yaml(fp,self.og_config,
            f'Scan chain "{self.config["name"]}" YAML configuration file')
        write_default_nettype(fp,'none')
        fp.write('\n')
        # Module Declaration
        total_def = f'[`{self.config["prefix"]}_TotalLength]'
        write_vlog_mod_begin(fp,self.config['name'],
            {'name': 'SClkP','io': 'input','datatype': 'wire','vec': None},
            {'name': 'SClkN','io': 'input','datatype': 'wire','vec': None},
            {'name': 'SReset','io': 'input','datatype': 'wire','vec': None},
            {'name': 'SEnable','io': 'input','datatype': 'wire','vec': None},
            {'name': 'SUpdate','io': 'input','datatype': 'wire','vec': None},
            {'name': 'SIn','io': 'input','datatype': 'wire','vec': None},
            {'name': 'SOut','io': 'output','datatype': 'wire','vec': None},
            {'name': 'Cfg','io': 'inout','datatype': 'wire','vec': total_def}
        )

    def write_defines(self,fp):
        ''' Writes the defines file '''
        # YAML config 
        write_yaml(fp,self.og_config,
            f'Scan chain "{self.config["name"]}" YAML configuration file')
        # Section: defines total length 
        write_begin_section(fp,"Total scan chain length") 
        write_define(fp,self.config['prefix']+'_TotalLength',self.full_width,tab='')
        write_end_section(fp) 
        # Section: iterate through cells and define flattened widths 
        write_begin_section(fp,"Defines for flattened segment widths") 
        for cell in self.config['cells']:
            write_define(fp,cell['full_name']+'_Width',
                cell['full_width'],tab='')
        write_end_section(fp)
        # Section: iterate through cells and define flattened vectors 
        write_begin_section(fp,"Defines for flattened vector segments") 
        for cell in self.config['cells']:
            write_define(fp,cell['full_name'],
                f"{cell['max_pos']}:{cell['min_pos']}",tab='')
        write_end_section(fp)
        # Section: iterate through cells and define mult functions 
        write_begin_section(fp,"Defines for multi-vector segments") 
        for cell in self.config['cells']:
            name = cell['full_name'] + '_idx(n)'
            value = f"(n * {cell['width']} + {cell['min_pos']}) +: {cell['width']}" 
            write_define(fp,name,value,tab='')
        write_end_section(fp)

    def gen_src(self,sfp,dfp):
        ''' generates the verilog source '''
        # Populate cell
        cw = 0 # current width
        for cell in self.config['cells']:
            cell['full_width'] = cell['width']*cell['mult'] 
            cell['full_name'] = self.config['prefix']+'_'+cell['name'] 
            cell['min_pos'] = cw 
            cell['max_pos'] = cell['full_width']+cw-1
            cw += cell['full_width']
        # Generate files 
        self.write_src(sfp)
        self.write_defines(dfp)
   
if __name__=='__main__':
    sg = ScanGenerator()
